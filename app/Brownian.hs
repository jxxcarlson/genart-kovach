module Brownian where

{-

Module for computing the paths generated by Brownian motion.
This is intended to be part of a later art project.
The next step is to make a render-to-SVG function.

-}


import Control.Monad.Random
import Linear.V2 ( V2(..) )  
import Linear.Vector ((^+^))


-- 1D Brownian path of length n
path :: RandomGen g => Int -> Rand g [Double]
path n = liftA2 (scanl (+)) (step) (steps n)

-- 2D Brownian path of length n
path2D :: RandomGen g => Int -> Rand g [(Double, Double)]
path2D n = liftA2 (scanl addPair) (step2D) (steps2D n)

-- 2D Brownian path of length n using V2
pathV2 :: RandomGen g => Double -> Double -> Int -> Rand g [(V2 Double)]
pathV2 x y n = liftA2 (scanl (^+^)) (origin x y) (stepsV2 n)

-- DEMO --

-- type 'main' in ghci
main2 = do
    moves <- evalRandIO $ pathV2 5 5 10
    print moves


-- HELPERS --

step :: RandomGen g => Rand g Double
step = getRandomR (-1,1)

liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
liftA2 h fa fb = h <$> fa <*> fb

step2D :: RandomGen g => Rand g (Double, Double)
step2D = liftA2 (,) (getRandomR (-1,1)) (getRandomR (-1,1))

stepV2 :: RandomGen g => Rand g (V2 Double)
stepV2 = liftA2 V2 (getRandomR (-1,1)) (getRandomR (-1,1))

origin ::  RandomGen g => Double -> Double -> Rand g (V2 Double)
origin x y = liftA2 (^+^) (pure (V2 x y)) stepV2

steps :: RandomGen g => Int -> Rand g [Double]
steps n = sequence (replicate n step)

steps2D :: RandomGen g => Int -> Rand g [(Double, Double)]
steps2D n = sequence (replicate n step2D)

stepsV2 :: RandomGen g => Int -> Rand g [(V2 Double)]
stepsV2 n = sequence (replicate n stepV2)

addPair :: (Double, Double) -> (Double, Double) -> (Double, Double)
addPair (x,y) (x', y') = (x + x', y + y')


